import 'dart:convert';
import 'dart:io';

import 'package:code_builder/code_builder.dart';
import 'package:country_state_city/country_state_city.dart';
import 'package:dart_style/dart_style.dart';
import 'package:path/path.dart' as path;

const dataFilePath = 'lib/assets/countries_states_cities.json';
const outputDirectoryPath = 'lib/src/data';

final dataFile = File(dataFilePath);
final outputDirectory = Directory(outputDirectoryPath);

final allocator = Allocator();
const countryStateCityImportUrl =
    'package:country_state_city/country_state_city.dart';
const countryStateCityDataImportDirectoryUrl =
    'package:country_state_city/src/data';
const outputFilePrefix = 'gen_';

final dartFormatter = DartFormatter();

const _doNotEditNotice =
    '''This file is automatically generated. DO NOT EDIT manually.''';

const countryClassName = 'Country';
const timezoneClassName = 'Timezone';
const countryStateClassName = 'CountryState';
const cityClassName = 'City';

Future<void> main() async {
  await outputDirectory.create(recursive: true);

  final countries = (jsonDecode(await dataFile.readAsString()) as List)
      .map<Country>((e) => Country.fromJson(e))
      .toList(growable: false);

  allocator.allocate(
    refer(
      countryClassName,
      countryStateCityImportUrl,
    ),
  );
  allocator.allocate(
    refer(
      timezoneClassName,
      countryStateCityImportUrl,
    ),
  );
  allocator.allocate(
    refer(
      countryStateClassName,
      countryStateCityImportUrl,
    ),
  );
  allocator.allocate(
    refer(
      cityClassName,
      countryStateCityImportUrl,
    ),
  );
  final references = await Future.wait(
      countries.map((country) => _writeCountriesAsync(country)));
  await _writeConsolidatedCountryFileAsync(references);
}

Future<void> _writeConsolidatedCountryFileAsync(
    List<Reference> references) async {
  final countryTokens = <String>[];
  final allocator = Allocator();
  for (final reference in references) {
    allocator.allocate(reference);
    countryTokens.add(reference.symbol!);
  }

  final LiteralListExpression countriesExp =
      literalList(countryTokens.map((countryToken) => refer(countryToken)));

  // Prepare to write file.

  final file = File(path.join(
    outputDirectory.path,
    'gen_countries.dart',
  ));
  final dartEmitter = DartEmitter(
    useNullSafetySyntax: true,
    allocator: allocator,
    orderDirectives: true,
  );

  final sb = StringBuffer();

  final String result = declareConst('kCountries')
      .assign(countriesExp)
      .statement
      .accept(dartEmitter)
      .toString();

  sb.writeln('// $_doNotEditNotice');
  sb.writeln();
  sb.writeln(allocator.imports
      .map((e) => e.accept(dartEmitter).toString())
      .join('\n'));

  sb.writeln(result);

  await file.writeAsString(dartFormatter.format(sb.toString()));
}

Future<Reference> _writeCountriesAsync(Country country) async {
  final countryExp = refer(countryClassName).constInstance(
    [],
    {
      'id': literal(country.id),
      'name': literal(country.name),
      'iso3': literal(country.iso3),
      'iso2': literal(country.iso2),
      'phoneCode': literal(country.phoneCode),
      'capital': literal(country.capital),
      'currency': literal(country.currency),
      'currencySymbol': literalString(country.currencySymbol, raw: true),
      'tld': literal(country.tld),
      'native': literal(country.native),
      'region': literal(country.region),
      'subregion': literal(country.subregion),
      'timezones': literalList(country.timezones.map(
        (timezone) => refer(timezoneClassName).constInstance(
          [],
          {
            'zoneName': literal(timezone.zoneName),
            'gmtOffset': literal(timezone.gmtOffset),
            'gmtOffsetName': literal(timezone.gmtOffsetName),
            'abbreviation': literal(timezone.abbreviation),
            'tzName': literal(timezone.tzName),
          },
        ),
      )),
      'emoji': literal(country.emoji),
      'emojiU': literal(country.emojiU),
      'states': literalList(country.states.map(
        (state) => refer(countryStateClassName).constInstance(
          [],
          {
            'id': literal(state.id),
            'name': literal(state.name),
            'stateCode': literal(state.stateCode),
            'cities': literalList(state.cities.map(
              (city) => refer(cityClassName).constInstance(
                [],
                {
                  'id': literal(city.id),
                  'name': literal(city.name),
                  'latitude': literal(city.latitude),
                  'longitude': literal(city.longitude),
                },
              ),
            )),
          },
        ),
      )),
    },
  );

  // Identify the token that we will use for generated file name and constant
  // name.

  final countryToken = country.iso3.toLowerCase();

  // Generate import reference.

  final outputFileName = '$outputFilePrefix$countryToken.dart';
  final reference = refer(
    countryToken,
    path.join(countryStateCityDataImportDirectoryUrl, outputFileName),
  );

  // Prepare to write file.

  final file = File(path.join(
    outputDirectory.path,
    outputFileName,
  ));
  final dartEmitter = DartEmitter(
    useNullSafetySyntax: true,
    allocator: allocator,
    orderDirectives: true,
  );
  final sb = StringBuffer();
  final String result = declareConst(countryToken)
      .assign(countryExp)
      .statement
      .accept(dartEmitter)
      .toString();

  sb.writeln('// $_doNotEditNotice');
  sb.writeln();
  sb.writeln(allocator.imports
      .map((e) => e.accept(dartEmitter).toString())
      .join('\n'));
  sb.writeln(result);

  await file.writeAsString(dartFormatter.format(sb.toString()));

  return reference;
}
